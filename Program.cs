using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Microsoft.CSharp;
using Network.Sim.Core;

namespace Network.Sim {
	class Program {
        /// <summary>
        /// The program's entry point.
        /// </summary>
        static void Main() {
	        var scenarios = GetScenarios();
            Scenario scenario = null;
            while (scenario == null) {
                Print("Select a simulation scenario:", ConsoleColor.Yellow);
                Print(string.Empty);
                for (var i = 1; i <= scenarios.Count; i++)
                    Print(i + " - " + scenarios[i - 1].Name);
                Print(string.Empty);
                var num = int.MaxValue;
                while (num > scenarios.Count)
                    num = ReadInt();
                var s = scenarios[num - 1];
                Print(s.Description, ConsoleColor.White);
                Print(string.Empty);
                Print("Run this scenario? (Y/N)", ConsoleColor.Yellow);
                if (char.ToLower(ReadChar('Y', 'y', 'N', 'n')) == 'y')
                    scenario = s;
                Console.Clear();
            }
            scenario.Run();
        }

        /// <summary>
        /// Gets a list of all available simulation scenarios.
        /// </summary>
        /// <returns>A list of available simulation scenarios.</returns>
        static IList<Scenario> GetScenarios() {
	        var assembly = CompileScripts(Directory.GetFiles("Scenarios", "*.cs"));
	        if (assembly == null)
	            return null;
	        return GetInstances<Scenario>(assembly);
	    }

	    /// <summary>
	    /// Compiles the specified collection of C# Source files and returns the generated assembly.
	    /// </summary>
	    /// <param name="scripts">A collection of C# Source files to compile.</param>
	    /// <returns>The assembly generated by the compiler.</returns>
	    /// <exception cref="ArgumentNullException">The scripts parameter is null.</exception>
	    static Assembly CompileScripts(IEnumerable<string> scripts) {
	        scripts.ThrowIfNull(nameof(scripts));
	        using (var csProvider = new CSharpCodeProvider()) {
	            var options = new CompilerParameters {
	                GenerateExecutable = false,
	                GenerateInMemory = true
	            };
	            options.ReferencedAssemblies.Add(Assembly.GetExecutingAssembly().Location);
	            var result = csProvider.CompileAssemblyFromFile(options, scripts.ToArray());
	            if (result.Errors.HasErrors) {
	                Print("Compilation of scenario scripts failed: ", ConsoleColor.Red);
	                foreach (CompilerError error in result.Errors) {
	                    var s = string.Format("* {0}, Line {1}: {2}", Path.GetFileName(error.FileName),
	                        error.Line, error.ErrorText);
	                    Print(s);
	                }
	                return null;
	            }
	            if (result.Errors.HasWarnings) {
	                Print("Compilation of scenario scripts generated warnings: ", ConsoleColor.Yellow);
	                foreach (CompilerError error in result.Errors) {
	                    if (!error.IsWarning)
	                        continue;
	                    var s = string.Format("* {0}, Line {1}: {2}", Path.GetFileName(error.FileName),
	                        error.Line, error.ErrorText);
	                    Print(s);
	                }
	                Print("");
	                Print("Continue execution? (Y/N)", ConsoleColor.Yellow);
	                if (char.ToLower(ReadChar('Y', 'y', 'N', 'n')) == 'n')
	                    return null;
	            }
	            return result.CompiledAssembly;
	        }
	    }

	    /// <summary>
        /// Prints the specified string on standard out using the specified
        /// text color.
        /// </summary>
        /// <param name="s">The string to print on standard out.</param>
        /// <param name="color">The text color to use for printing.</param>
        static void Print(string s, ConsoleColor color = ConsoleColor.Gray) {
            var old = Console.ForegroundColor;
            Console.ForegroundColor = color;
            Console.WriteLine(s);
            Console.ForegroundColor = old;
        }

	    /// <summary>
        /// Reads an integer from the console.
        /// </summary>
        /// <returns>The read integer.</returns>
	    static int ReadInt() {
	        while (true) {
	            var key = Console.ReadKey(true);
	            int num;
                if (int.TryParse(key.KeyChar.ToString(), out num))
                    return num;
	        }
	    }

        /// <summary>
        /// Reads a character from the console.
        /// </summary>
        /// <param name="subset">A subset of allowed characters.</param>
        /// <returns>The read character.</returns>
	    static char ReadChar(params char[] subset) {
	        while (true) {
	            var key = Console.ReadKey(true);
	            if (!subset.Any() || subset.Contains(key.KeyChar))
	                return key.KeyChar;
	        }
	    }

        /// <summary>
        /// Gets a list of instances of all types of the executing assembly that are derived from
        /// the specified base-type.
        /// </summary>
        /// <typeparam name="T">The base-type.</typeparam>
        /// <param name="assembly">The assembly to reflect over.</param>
        /// <returns>A list of instances of all types derived from the specified base-type.</returns>
        static IList<T> GetInstances<T>(Assembly assembly) {
            return (from t in assembly.GetTypes()
                    where t.BaseType == typeof(T) && t.GetConstructor(Type.EmptyTypes) != null
                    select (T)Activator.CreateInstance(t)).ToList();
        }
    }
}